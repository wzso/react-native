enum Direction {
  Up,
  Down,
  Right,
  Left
}

/////// 类型推论 type inference
// 最佳通用类型
// 当需要从几个表达式中推断类型时候，会使用这些表达式的类型来推断出一个最合适的通用类型。


/////// 类型兼容性 type compatibility
/* TypeScript里的类型兼容性是基于结构子类型 structural typing 的
结构类型是一种只使用其成员来描述类型的方式 它正好与名义 nominal 类型形成对比
译者注：在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明和/或类型的名称来决定的
这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明 */
interface Named {
  name: string;
}
class Person {
  name: string;
}
let p: Named;
// OK, because of structural typing
p = new Person();
// 在基于名义类型如Java/C#中，这段代码会报错，因为Person类没有明确说明实现了Named interface
// TypeScript的结构性子类型是根据JavaScript代码的典型写法来设计的
// 因为JS广泛使用匿名对象，例如函数表达式和对象字面量，所以使用结构类型系统来描述这些类型比使用名义类型系统更好


// 函数重载
/* 对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名
这确保了目标函数可以在所有源函数可调用的地方调用 */


// 枚举
/* 枚举类型与数字类型兼容，并且数字类型与枚举类型兼容
不同枚举类型之间是不兼容的*/


// 类
/**
 * 类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型
 * 比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内
 * 
 * 私有成员会影响兼容性判断。 当类的实例用来检查兼容时，
 * 如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员
 * 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。
 */